import subprocess
import os
import tempfile
import sys

class ExploitRunner:
    def run_poc(self, poc_code: str) -> dict:
        """
        Executes the provided Python PoC code in a temporary environment.
        Supports both standalone scripts and 'run(target_url)' function style.
        """
        
        # Append wrapper to invoke 'run(TARGET_URL)' if it exists
        # We assume TARGET_URL is defined in global scope by the caller (main.py)
        wrapper_code = """
import json
try:
    if 'run' in locals() and callable(locals()['run']):
        # If TARGET_URL is not defined, try to find it or default
        tgt = locals().get('TARGET_URL', '')
        res = run(tgt)
        print("---JSON_OUTPUT_START---")
        print(json.dumps(res))
        print("---JSON_OUTPUT_END---")
except Exception as e:
    print(f"Wrapper Error: {e}")
"""
        full_code = poc_code + "\n" + wrapper_code

        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as tmp_file:
            tmp_file.write(full_code)
            tmp_path = tmp_file.name

        try:
            # Running with a timeout
            result = subprocess.run(
                [sys.executable, tmp_path],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            output = result.stdout + result.stderr
            
            # 1. Check for JSON output from wrapper
            import json
            if "---JSON_OUTPUT_START---" in output:
                try:
                    json_str = output.split("---JSON_OUTPUT_START---")[1].split("---JSON_OUTPUT_END---")[0].strip()
                    parsed = json.loads(json_str)
                    return {
                        "success": parsed.get("success", False),
                        "output": parsed.get("output", output),
                        "exit_code": result.returncode
                    }
                except:
                    pass

            # 2. Fallback: Check for keywords in raw output
            success = "[+] VULNERABILITY CONFIRMED" in output or "Success" in output or "[+]" in output
            
            # Refine success check: verify it's not a failure message
            if "[-] " in output and "[+]" not in output:
                success = False

            return {
                "success": success,
                "output": output,
                "exit_code": result.returncode
            }
        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "output": "Execution timed out.",
                "exit_code": -1
            }
        except Exception as e:
            return {
                "success": False,
                "output": f"Execution error: {str(e)}",
                "exit_code": -1
            }
        finally:
            if os.path.exists(tmp_path):
                os.remove(tmp_path)

exploit_runner = ExploitRunner()
